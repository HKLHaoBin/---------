<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>.lys 歌词顺序编辑器（拖放版）</title>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans', Arial, 'PingFang SC', 'Hiragino Sans GB', sans-serif; color: #222; }
    header { padding: 12px 16px; background: #f6f7f9; border-bottom: 1px solid #e9eaee; }
    h1 { margin: 0 0 8px 0; font-size: 20px; }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .controls input[type=file] { padding: 4px; }
    .controls button { padding: 6px 10px; border: 1px solid #ddd; background: #fff; border-radius: 6px; cursor: pointer; }
    .controls button:disabled { opacity: 0.5; cursor: not-allowed; }
    main { display: grid; grid-template-columns: 1fr 340px; gap: 16px; padding: 16px; }
    .panel { border: 1px solid #e9eaee; border-radius: 8px; padding: 12px; background: #fff; }
    #lines { display: flex; flex-direction: column; gap: 8px; }
    .line { display: flex; gap: 6px; flex-wrap: wrap; padding: 8px; border: 1px dashed #ddd; border-radius: 6px; }
    .line.meta { background: #fafafa; }
    .prefix { color: #999; margin-right: 6px; }
    .tok { display: inline-block; padding: 4px 8px; border: 1px solid #ddd; border-radius: 6px; cursor: grab; user-select: none; }
    .tok:active { cursor: grabbing; }
    .tok:hover { border-color: #bbb; }
    .tok.selected { background: #fbf0ff; border-color: #ba77ff; }
    .tok.anchor { outline: 2px solid #0077ff; }
    .tok.drop-left { box-shadow: -2px 0 0 0 #0a7cff inset; }
    .tok.drop-right { box-shadow:  2px 0 0 0 #0a7cff inset; }
    .box { background: #f8fbff; padding: 8px; border: 1px solid #e0eefc; border-radius: 6px; }
    #status { margin-top: 8px; color: #555; min-height: 1.4em; }
    #docInfo { color: #555; margin-bottom: 8px; }
    .muted { color: #777; font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <h1>.lys 歌词顺序编辑器（多选拖放，前端不显示时间戳）</h1>
    <div class="controls">
      <input type="file" id="fileInput" accept=".lys,.lrc,.txt" />
      <button id="btnImport">导入 .lys</button>
      <button id="btnUndo" disabled>撤销</button>
      <button id="btnRedo" disabled>重做</button>
      <button id="btnExport" disabled>导出 .lys</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <h2>文档</h2>
      <div id="docInfo"></div>
      <div id="lines"></div>
    </section>

    <section class="panel">
      <h2>用法</h2>
      <div class="box">
        <p>① <strong>Ctrl/⌘ 多选</strong>歌词块；或只选一个。</p>
        <p>② 把选中的块<strong>直接拖动</strong>到另一行的某个块上；根据鼠标落点在该块的左半/右半，决定插入到<strong>前面/后面</strong>。</p>
        <p class="muted">提示：页面不显示时间戳，但时间戳会随 token 一起移动；导出时时间戳会保留。</p>
      </div>
      <div id="status"></div>
    </section>
  </main>

  <script>
    const $ = (sel) => document.querySelector(sel);

    let state = {
      doc: null,
      selectedTokenIds: new Set(),
    };

    function setStatus(msg) {
      $('#status').textContent = msg || '';
    }

    function renderDoc() {
      const c = $('#lines');
      c.innerHTML = '';
      if (!state.doc) return;
      $('#docInfo').textContent = `DocID: ${state.doc.id} — version: ${state.doc.version} — 行数: ${state.doc.lines.length}`;

      state.doc.lines.forEach((line) => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'line' + (line.is_meta ? ' meta' : '');
        lineDiv.dataset.lineId = line.id;

        if (line.prefix) {
          const pre = document.createElement('span');
          pre.className = 'prefix';
          pre.textContent = line.prefix;
          lineDiv.appendChild(pre);
        }

        line.tokens.forEach((tok) => {
          const span = document.createElement('span');
          span.className = 'tok';
          // 不显示时间戳，只显示文本
          span.textContent = tok.text || '(空)';
          span.title = `tokenId=${tok.id}`; // 不显示时间戳
          span.dataset.tokenId = tok.id;
          span.dataset.lineId = line.id;
          span.draggable = !line.is_meta;  // meta 行不允许拖拽

          if (state.selectedTokenIds.has(tok.id)) span.classList.add('selected');

          // 点击：多选/取消
          span.addEventListener('click', (e) => {
            const multi = e.metaKey || e.ctrlKey;
            if (multi) {
              if (state.selectedTokenIds.has(tok.id)) state.selectedTokenIds.delete(tok.id);
              else state.selectedTokenIds.add(tok.id);
            } else {
              // 单击切换选择到这个 token（便于单选拖动）
              state.selectedTokenIds.clear();
              state.selectedTokenIds.add(tok.id);
            }
            renderDoc();
          });

          // 拖拽开始：若当前 token 不在选择中，则将选择重置为该 token
          span.addEventListener('dragstart', (e) => {
            if (!state.selectedTokenIds.has(tok.id)) {
              state.selectedTokenIds.clear();
              state.selectedTokenIds.add(tok.id);
              renderDoc();
            }
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', 'drag'); // 占位以启用拖拽
          });

          // 在 token 上方悬停：决定 before / after 的视觉提示
          span.addEventListener('dragover', (e) => {
            if (!state.doc) return;
            e.preventDefault(); // 允许 drop
            const rect = span.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            span.classList.toggle('drop-left', isLeft);
            span.classList.toggle('drop-right', !isLeft);
          });

          // 离开时清理样式
          span.addEventListener('dragleave', () => {
            span.classList.remove('drop-left', 'drop-right');
          });

          // 放下：计算 before/after，构造 selection + target，调用 /api/move
          span.addEventListener('drop', async (e) => {
            e.preventDefault();
            const rect = span.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            span.classList.remove('drop-left', 'drop-right');
            await doDropMove({
              anchorLineId: span.dataset.lineId,
              anchorTokenId: span.dataset.tokenId,
              position: isLeft ? 'before' : 'after',
            });
          });

          lineDiv.appendChild(span);
        });

        c.appendChild(lineDiv);
      });
    }

    // 将选中的 token ID 集合合并成若干个 [start_id, end_id] 的连续区间（逐行）
    function groupSelectionIntoRanges() {
      if (!state.doc) return [];
      const idToIndex = new Map();
      state.doc.lines.forEach((line, li) => {
        line.tokens.forEach((tok, ti) => {
          idToIndex.set(tok.id, { li, ti, line_id: line.id });
        });
      });

      const selected = Array.from(state.selectedTokenIds)
        .map((id) => idToIndex.get(id))
        .filter(Boolean)
        .sort((a, b) => (a.li - b.li) || (a.ti - b.ti));

      const ranges = [];
      let i = 0;
      while (i < selected.length) {
        const { li, line_id } = selected[i];
        let startTi = selected[i].ti;
        let endTi = startTi;

        let j = i + 1;
        while (j < selected.length && selected[j].li === li && selected[j].ti === endTi + 1) {
          endTi = selected[j].ti;
          j++;
        }
        const line = state.doc.lines[li];
        const start_token_id = line.tokens[startTi].id;
        const end_token_id = line.tokens[endTi].id;
        ranges.push({ line_id, start_token_id, end_token_id });
        i = j;
      }
      return ranges;
    }

    async function doDropMove({ anchorLineId, anchorTokenId, position }) {
      if (!state.doc) return;
      const selectionRanges = groupSelectionIntoRanges();
      if (selectionRanges.length === 0) {
        setStatus('请先选择要移动的歌词块（可 Ctrl/⌘ 多选）');
        return;
      }

      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        selection: selectionRanges,
        target: {
          type: 'anchor',
          line_id: anchorLineId,
          anchor_token_id: anchorTokenId,
          position: position // 'before' | 'after'
        }
      };

      const res = await fetch('/api/move', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const text = await res.text();
        setStatus('移动失败：' + text);
        return;
      }
      const doc = await res.json();
      state.doc = doc;
      // 成功后默认清空选择，避免误拖
      state.selectedTokenIds.clear();
      renderDoc();
      setStatus('已完成拖放移动。');
    }

    // ---- 基础 API 调用（导入、导出、撤销、重做） ----
    async function importLys(file) {
      const fd = new FormData();
      fd.append('file', file);
      const res = await fetch('/api/import', { method: 'POST', body: fd });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || '导入失败');
      }
      const doc = await res.json();
      state.doc = doc;
      state.selectedTokenIds.clear();
      renderDoc();
      $('#btnExport').disabled = false;
      $('#btnUndo').disabled = false;
      $('#btnRedo').disabled = false;
    }

    async function exportLys() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await fetch('/api/export?' + params.toString(), { method: 'GET' });
      const text = await res.text();
      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'edited.lys';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    async function undo() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await fetch('/api/undo?' + params.toString(), { method: 'POST' });
      if (!res.ok) { setStatus('无法撤销'); return; }
      const doc = await res.json();
      state.doc = doc;
      renderDoc();
    }

    async function redo() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await fetch('/api/redo?' + params.toString(), { method: 'POST' });
      if (!res.ok) { setStatus('无法重做'); return; }
      const doc = await res.json();
      state.doc = doc;
      renderDoc();
    }

    function init() {
      $('#btnImport').addEventListener('click', async () => {
        const f = $('#fileInput').files[0];
        if (!f) { setStatus('请选择一个 .lys 文件'); return; }
        try {
          await importLys(f);
          setStatus('导入成功。');
        } catch (e) {
          setStatus(String(e));
        }
      });

      $('#btnExport').addEventListener('click', exportLys);
      $('#btnUndo').addEventListener('click', undo);
      $('#btnRedo').addEventListener('click', redo);

      // 点击空白处清空选择
      $('#lines').addEventListener('click', (e) => {
        if (e.target.classList.contains('tok')) return;
        state.selectedTokenIds.clear();
        renderDoc();
      });
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
